/** @file src/python/plant.cpp
 * @brief Python API generated by pybind11
 */

#include <string>

#include <pybind11/pybind11.h>
#include <pybind11/operators.h>
#include <pybind11/stl.h>

#include "plant/core/transforms.hpp"
#include "plant/core/types.hpp"
#include "plant/filters/kalman_filter.hpp"
#include "plant/math/matrix.hpp"
#include "plant/math/quaternion.hpp"
#include "plant/math/vector.hpp"
#include "plant/sensors/imu.hpp"

namespace py = pybind11;

PYBIND11_MODULE(_plant, m) {
    m.doc() = "Python Library for Autonomous Navigation and Tracking (PLANT)";

    // Filters module
    auto m_filters = m.def_submodule("filters", "Filters");

    py::class_<plant::filters::KalmanFilter>(m_filters, "KalmanFilter")
        .def(py::init<plant::math::Vector>(), py::arg("x"))
        .def_readwrite("x", &plant::filters::KalmanFilter::x)
        .def_readwrite("y", &plant::filters::KalmanFilter::y)
        .def("predict", &plant::filters::KalmanFilter::predict);

    // Math module
    auto m_math = m.def_submodule("math", "Math primitives");

    py::class_<plant::math::Matrix<3, 3>>(m_math, "Matrix3")
        .def(py::init<>())
        .def("__getitem__", [](const plant::math::Matrix<3, 3>& self, std::pair<int, int> index) {
            return self(index.first, index.second);
        })
        .def("__setitem__", [](plant::math::Matrix<3, 3>& self, std::pair<int, int> index, float value) {
            self(index.first, index.second) = value;
        })
        .def("__repr__", [](const plant::math::Matrix<3, 3>& m) {
            std::string result = "Matrix(\n";
            for (int i = 0; i < 3; i++) {
                result += "    ";
                for (int j = 0; j < 3; j++) {
                    if (j < 2) {
                        result += std::to_string(m(i, j)) + ", ";
                        continue;
                    }
                    result += std::to_string(m(i, j)) + ",\n";
                }
            }
            result += ")";
            return result;
        });

    m_math.def("Matrix", [](int rows, int cols) -> py::object {
        if (rows == 3 && cols == 3) {
            return py::cast(plant::math::Matrix<3, 3>());
        } else {
            throw std::runtime_error(
                "Unsupported matrix size: " + \
                std::to_string(rows) + "x" + std::to_string(cols)
            );
        }
    });

    py::class_<plant::math::Quaternion>(m_math, "Quaternion")
        .def(py::init<>())
        .def(py::init<float, float, float, float>(), py::arg("w"), py::arg("x"), py::arg("y"), py::arg("z"))
        .def_readwrite("w", &plant::math::Quaternion::w)
        .def_readwrite("x", &plant::math::Quaternion::x)
        .def_readwrite("y", &plant::math::Quaternion::y)
        .def_readwrite("z", &plant::math::Quaternion::z)
        .def("normalize", &plant::math::Quaternion::normalize)
        .def("to_matrix", &plant::math::Quaternion::to_matrix)
        .def(py::self + py::self)
        .def("__repr__", [](const plant::math::Quaternion& q) {
            return (
                "Quaternion(\n    " + \
                std::to_string(q.w) + ",\n    " + \
                std::to_string(q.x) + ",\n    " + \
                std::to_string(q.y) + ",\n    " + \
                std::to_string(q.z) + "," \
                "\n)"
            );
        });

    py::class_<plant::math::Vector>(m_math, "Vector")
        .def(py::init<>())
        .def(py::init<float, float, float>(), py::arg("x"), py::arg("y"), py::arg("z"))
        .def_readwrite("x", &plant::math::Vector::x)
        .def_readwrite("y", &plant::math::Vector::y)
        .def_readwrite("z", &plant::math::Vector::z)
        .def("normalize", &plant::math::Vector::normalize)
        .def(py::self + py::self)
        .def(py::self - py::self)
        .def(py::self * py::self)
        .def("__repr__", [](const plant::math::Vector& v) {
            return (
                "Vector(\n    " + \
                std::to_string(v.x) + ",\n    " + \
                std::to_string(v.y) + ",\n    " + \
                std::to_string(v.z) + "," \
                "\n)"
            );
        });

    // Core types module
    auto m_types = m.def_submodule("types", "Core types");

    // Enums
    py::enum_<plant::core::types::AltType>(m_types, "AltType")
        .value("HeightAboveGeoid",
               plant::core::types::AltType::HeightAboveGeoid)
        .value("HeightAboveEllipsoid",
               plant::core::types::AltType::HeightAboveEllipsoid)
        .value("MeanSeaLevel", plant::core::types::AltType::MeanSeaLevel);

    py::enum_<plant::core::types::ReferenceFrame>(m_types, "ReferenceFrame")
        .value("EarthCenteredInertial",
               plant::core::types::ReferenceFrame::EarthCenteredInertial)
        .value("EarthCenteredEarthFixed",
               plant::core::types::ReferenceFrame::EarthCenteredEarthFixed)
        .value("EastNorthUp", plant::core::types::ReferenceFrame::EastNorthUp)
        .value("NorthEastDown",
               plant::core::types::ReferenceFrame::NorthEastDown)
        .value("Body", plant::core::types::ReferenceFrame::Body);

    // Classes
    py::class_<plant::core::types::Vector3f>(m_types, "Vector3f")
        .def(py::init<float, float, float>())
        .def_readwrite("x", &plant::core::types::Vector3f::x)
        .def_readwrite("y", &plant::core::types::Vector3f::y)
        .def_readwrite("z", &plant::core::types::Vector3f::z)
        .def(
            "__add__",
            [](const plant::core::types::Vector3f& u,
               plant::core::types::Vector3f v) {
                plant::core::types::Vector3f w = {u.x + v.x, u.y + v.y,
                                                  u.z + v.z};
                return w;
            },
            py::is_operator())
        .def(
            "__sub__",
            [](const plant::core::types::Vector3f& u,
               plant::core::types::Vector3f v) {
                plant::core::types::Vector3f w = {u.x - v.x, u.y - v.y,
                                                  u.z - v.z};
                return w;
            },
            py::is_operator());

    py::class_<plant::core::types::LatLonAlt>(m_types, "LatLonAlt")
        .def(py::init<>())
        .def(py::init<float, float, float, plant::core::types::AltType>(),
             py::arg("lat"), py::arg("lon"), py::arg("alt"),
             py::arg("alt_type"))
        .def_readwrite("lat", &plant::core::types::LatLonAlt::lat)
        .def_readwrite("lon", &plant::core::types::LatLonAlt::lon)
        .def_readwrite("alt", &plant::core::types::LatLonAlt::alt)
        .def_readwrite("alt_type", &plant::core::types::LatLonAlt::alt_type);

    py::class_<plant::core::types::CartPos>(m_types, "CartPos")
        .def(py::init<>())
        .def(
            py::init<float, float, float, plant::core::types::ReferenceFrame>(),
            py::arg("x"), py::arg("y"), py::arg("z"), py::arg("rf"))
        .def_readwrite("x", &plant::core::types::CartPos::x)
        .def_readwrite("y", &plant::core::types::CartPos::y)
        .def_readwrite("z", &plant::core::types::CartPos::z)
        .def_readwrite("rf", &plant::core::types::CartPos::rf);

    py::class_<plant::core::types::CartVel>(m_types, "CartVel")
        .def(py::init<>())
        .def(
            py::init<float, float, float, plant::core::types::ReferenceFrame>(),
            py::arg("vx"), py::arg("vy"), py::arg("vz"), py::arg("rf"))
        .def_readwrite("vx", &plant::core::types::CartVel::vx)
        .def_readwrite("vy", &plant::core::types::CartVel::vy)
        .def_readwrite("vz", &plant::core::types::CartVel::vz)
        .def_readwrite("rf", &plant::core::types::CartVel::rf);

    py::class_<plant::core::types::CartAcc>(m_types, "CartAcc")
        .def(py::init<>())
        .def(
            py::init<float, float, float, plant::core::types::ReferenceFrame>(),
            py::arg("ax"), py::arg("ay"), py::arg("az"), py::arg("rf"))
        .def_readwrite("ax", &plant::core::types::CartAcc::ax)
        .def_readwrite("ay", &plant::core::types::CartAcc::ay)
        .def_readwrite("az", &plant::core::types::CartAcc::az)
        .def_readwrite("rf", &plant::core::types::CartAcc::rf);

    py::class_<plant::core::types::AttRpy>(m_types, "AttRpy")
        .def(py::init<>())
        .def(py::init<float, float, float>(), py::arg("roll"), py::arg("pitch"),
             py::arg("yaw"))
        .def_readwrite("roll", &plant::core::types::AttRpy::roll)
        .def_readwrite("pitch", &plant::core::types::AttRpy::pitch)
        .def_readwrite("yaw", &plant::core::types::AttRpy::yaw);

    py::class_<plant::core::types::AttQuat>(m_types, "AttQuat")
        .def(py::init<>())
        .def(py::init<float, float, float, float>(), py::arg("w"), py::arg("x"),
             py::arg("y"), py::arg("z"))
        .def_readwrite("w", &plant::core::types::AttQuat::w)
        .def_readwrite("x", &plant::core::types::AttQuat::x)
        .def_readwrite("y", &plant::core::types::AttQuat::y)
        .def_readwrite("z", &plant::core::types::AttQuat::z);

    py::class_<plant::core::types::State>(m_types, "State")
        .def(py::init<>())
        .def(
            py::init<plant::core::types::CartPos, plant::core::types::CartVel,
                     plant::core::types::CartAcc, plant::core::types::LatLonAlt,
                     plant::core::types::AttRpy, plant::core::types::AttQuat>(),
            py::arg("p"), py::arg("v"), py::arg("a"), py::arg("lla"),
            py::arg("rpy"), py::arg("q"))
        .def_readwrite("p", &plant::core::types::State::p)
        .def_readwrite("v", &plant::core::types::State::v)
        .def_readwrite("a", &plant::core::types::State::a)
        .def_readwrite("lla", &plant::core::types::State::lla)
        .def_readwrite("rpy", &plant::core::types::State::rpy)
        .def_readwrite("q", &plant::core::types::State::q);

    // Transforms module
    auto m_transforms = m.def_submodule("transforms");

    // Methods
    m_transforms.def("dot_v3f", &plant::core::transforms::dot_v3f, py::arg("u"),
                     py::arg("v"));

    m_transforms.def("cross_v3f", &plant::core::transforms::cross_v3f,
                     py::arg("u"), py::arg("v"));

    // Sensors module
    auto m_sensors = m.def_submodule("sensors");

    // Classes
    py::class_<plant::sensors::IMU>(m_sensors, "IMU")
        .def(py::init<>())
        .def(py::init<float, float>(), py::arg("wx"), py::arg("wy"))
        .def_readwrite("wx", &plant::sensors::IMU::wx)
        .def_readwrite("wy", &plant::sensors::IMU::wy)
        .def(
            "__repr__",
            [](const plant::sensors::IMU& imu) {
                return "[" + std::to_string(imu.wx) + ", " +
                       std::to_string(imu.wy) + "]";
            },
            py::is_operator());
}
